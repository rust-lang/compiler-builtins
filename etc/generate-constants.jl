using Printf

function main()
    repo_root = dirname(@__DIR__)
    out_dir = joinpath(repo_root, "libm/src/math/generic/generated")

    mod_contents = "// autogenerated\n\n"
    
    cfg = Config(out_dir)
    mod_contents *= update_rem_pio2(cfg)

    path = joinpath(cfg.out_dir, "mod.rs")
    write(path, mod_contents)
    println("wrote $path")
end

struct Config
    out_dir::String
end

@enum FloatTy F16 F32 F64 F128

struct TyInfo
    bits::UInt32
    sig_bits::UInt32
    ity::Type
    ty_name::String
end

function ty_info(fty::FloatTy)::TyInfo
    if fty == F16
        bits = 16
        sig_bits = 10
        ity = UInt16
    elseif fty == F32
        bits = 32
        sig_bits = 23
        ity = UInt32
    elseif fty == F64
        bits = 64
        sig_bits = 52
        ity = UInt64
    elseif fty == F128
        bits = 128
        sig_bits = 112
        ity = UInt128
    else
        @assert(false)
    end

    return TyInfo(
        bits,
        sig_bits,
        ity,
        lowercase(string(fty)),
    )
end

function update_rem_pio2(cfg::Config)::String
    prefix= """
        use crate::support::HalfRep;
        use super::super::rem_pio2::RemPio2Support;
        """
    ret = ""

    for fty in [F64]
        info = ty_info(fty)
        ty_name = info.ty_name
        halfbits = info.bits / 2

        if info.bits == 32 || info.bits == 64
            to_bits = "$(ty_name)_to_bits"
            prefix *= "use crate::support::$to_bits;\n"
        else
            to_bits = "$ty_name::to_bits"
        end

        hi_int(x::BigFloat) = @sprintf "(%s(hf%d!(\"%a\")) >> %d) as u%d" to_bits info.bits x halfbits halfbits
        
        setprecision(ty_info(fty).sig_bits + 1)
        
        ty_impl = """
            impl RemPio2Support for $ty_name {
                const TO_INT: Self = 1.5 / $ty_name::EPSILON;
                const INV_PIO2: Self = 6.36619772367581382433e-01;
                const PIO2_1: Self = 1.57079632673412561417e+00;
                const PIO2_1T: Self = 6.07710050650619224932e-11;
                const PIO2_2: Self = 6.07710050630396597660e-11;
                const PIO2_2T: Self = 2.02226624879595063154e-21;
                const PIO2_3: Self = 2.02226624871116645580e-21;
                const PIO2_3T: Self = 8.47842766036889956997e-32;

                const FRAC_5PI_4_HI: HalfRep<Self> = $(hi_int(big(pi)*5/4));
                const FRAC_3PI_4_HI: HalfRep<Self> = $(hi_int(big(pi)*3/4));
                const FRAC_9PI_4_HI: HalfRep<Self> = $(hi_int(big(pi)*9/4));
                const FRAC_7PI_4_HI: HalfRep<Self> = $(hi_int(big(pi)*7/4));
                const FRAC_3PI_2_HI: HalfRep<Self> = $(hi_int(big(pi)*3/2));
                const TAU_HI: HalfRep<Self> = $(hi_int(big(pi)*2));
                const FRAC_PI_2_HI: HalfRep<Self> = 0x921fb;
                const FRAC_2_POW_20_PI_2: HalfRep<Self> = $(hi_int((big(2)^20) * pi / 2));

                const MAGIC_F: Self = hf64!("0x1p24");

                fn large(x: &[Self], y: &mut [Self], e0: i32, prec: usize) -> i32 {
                    super::super::super::rem_pio2_large(x, y, e0, prec)
                }
            }
            """
        ret *= ty_impl
    end

    ret = prefix * "\n" * ret
    path = joinpath(cfg.out_dir, "rem_pio2.rs")
    write(path, ret)
    println("wrote $path")
        
    return "mod rem_pio2;"
end

main()
